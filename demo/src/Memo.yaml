#https://gobyexample.com
1: 方法
  - 普通方法格式：方法名（参数）返回值----func plus(a int, b int) int {}
  - 结构体或者接口的实现方法格式：(参数[不是普通类型是具体的结构体名字])方法名／返回值----func (r rect) area() float64 {}
  - 结构体或者接口的实现方法格式：参数中都可以使用指针

2: 通道
  # http://blog.csdn.net/kjfcpua/article/details/18265441
  - 无缓冲信道进出顺序：参考channels.go(先到先出)
  - 缓冲信道会在满容量的时候加锁。如果不把容量中的取走，不管有没有取数据的代码都会报错 - deadlock!：参考channelBuffering.go(先到先出)
  - 通道进出不一定要一对一，多个进一个出也可以：参考channelDirections.go
  - 但干涸的通道不能再读，即不能一个进多个出：参考channelRange.go，channelDirections.go

  - 阻塞：不能再往chan里放东西，参考channelSynchronization.go
    - 默认的，信道的存消息和取消息都是阻塞的,也就是说, 无缓冲的信道在取消息和存消息的时候都会挂起当前的goroutine，除非另一端已经准备好。
  	- 其实，无缓冲的信道永远不会存储数据，只负责数据的流通，为什么这么讲呢？
      - 从无缓冲信道取数据，必须要有数据流进来才可以，否则当前线阻塞
      - 数据流入无缓冲信道, 如果没有其他goroutine来拿走这个数据，那么当前线阻塞
  - 死锁：参考channelSynchronization.go
  	- 死锁：fatal error：all goroutines are asleep - deadlock!
  	- 非缓冲信道上如果发生了流入无流出，或者流出无流入，也就导致了死锁。
  	- 解决办法：
  	  - 1.所有进出成对出现
  	  - 2.添加一个缓冲区，不达容量不阻塞。达容量后再放一个会报错，缓冲信道会在满容量的时候
  - 无缓冲的信道是一批数据一个一个的「流进流出」，缓冲信道则是一个一个存储，然后一起流出去
  - 不在main线程里的channel，不遵循以上死锁规则？？？？

3: 键盘输入
	fmt.Scanln(&str)，参考channels.go

4: 接口
	多个实现的时候，把接口转化成具体某一个实现类：errorsInterface.go

5: 反射
    #https://www.golangtc.com/t/53317f90320b5261e0000058
	reflect是用来取interface的内容的，而空interface（interface{}）主要包括Value（data域）、Type（itab）两个对象。

	Interface就存两个指针，一个是指向数据的一些类型信息；另一个数据域的指针指向的是一个全新的拷贝，不是直接把指针指向了原对象，对于它的修
	改对原来的数据是没有影响的。如果想要修改原值，就要用指针。再用p.Elem就能获得可以修改的对象了。

	如果是channel，slice，func也一样，Value存的是空值，Type存的是 func(int,int)(int,int)或者func(float,float)(float,float)。













